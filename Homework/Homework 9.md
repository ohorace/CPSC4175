## Olivia Horace  
### Homework 09, CPSC-4175   

**1. The book depicts an ideal software process as a linear flow, like this: Requirements > Analysis > Design > Implementation. The book then notes that “software development is considerably different in practice[.]” Which reason do you think is more important for this difference, human error or changing requirements? Why?**  
I think that changing requirements are the most important reason for this difference. If at any point during a project the requirements change, the process will revert back to the first phase. Sometimes it won't even go back to the beginning. It can go back to the design phase and start from there. Whenever the requirements change it can disrupt the current workflow.  
  
**2. What do you think that the book means when it says that “the waterfall model, which was first put forward in 1970, is iterative (but not incremental)?”**  
In waterfall, the steps (requirements, analysis, design, and implementation) are completed in a cycle until they are complete. Even though the book later says that iteration and incremental are often used together, the idea of waterfall was designed as an iterative process.  
  
**3. Using the book’s explanation of stepwise refinement, relate an account from your previous personal experience when you used this type of development model. This does not have to be software related. Were you successful in your development? Why or why not?**  
Usually, when I have a lot of assignments or work due in my classes I use stepwise refinement. I will focus solely on the bigger tasks first as well as the ones that are more crucial in my grade calculation. Then I will come back to the tasks I have that are less important or those that won't require much time.  

**4. Looking at figure 2.4 in the book, you see that the Requirements workflow ceases at some point early in iteration 3, while the Test workflow runs from the very beginning of iteration 1 and ends at the veryend of iteration 4. Make the case that the Requirements workflow should occur in all iterations. Make the case that the Test workflow should not begin until iteration 2 at the earliest.**  
The requirements workflow should occur in all iterations because they can always be refined. The requirements document is a living document and will need to be updated several times during the process. Each time it the document is revised it should become more detailed and clear.  

The testing workflow should begin in iteration 2 when there is more than one module to test. This way you can test the integration of pieces and how they work together. After the first interation there may not be anything to truly test. Likewise, the outcome of the first iteration may be very crude and hard to test. 

**5. Iterative and Incremental Model The book notes that “each iteration can be viewed as a small but complete waterfall model.” This is sometimes called the cascade model. Think about your experience in building your class project. How would you explain the iterative and incremental model to a young programmer who asked you how it worked. This question calls for a reflection on your experience, not a textbook answer. (Note that the iterative and incremental model and the spiral model are not the same thing — in this class we are using the spiral model.)**  
I would explain the **iterative** model as being a series of steps taken multiple times. As a result, you would follow the same steps, in the same order, in a cycle multiple times until you have developed the software product.  

I would explain the **incremental** model as being development piece by piece. For example, when creating a requirement artifact, incrementation would be creating this piece by piece. So for the first step (requirements phase), gathering the actual requirements, drafting the document and then preparing a readable and detailed document would demonstrate incrementation. This would then be completed, multiple times in different phases for the iterative part of the development cycle.  

**6. The book notes that “[a] critical point regarding the waterfall model is that no phase is complete until the documentation for that phase has been completed[.]” Do you agree with this statement? If this statement were true, what changes in your personal process would you make to conform to this dictate?**  
I agree with this statement because that will help along the way in the process by having documentation to see what was done and why. However, in our project that hasn't been the case. I didn't even think that we needed to document anything beyond having our artifacts needed for that phase. If I had an idea of what specific kind of documentation was needed then that would be something that could easily be incorporated into our project.  

**7. The book discusses nine process models:   
(a) Evolution-tree Life-cycle Model  
(b) Iterative-and-incremental Life-cycle Model  
(c) Code-and-Fix Life-Cycle Model  
(d) Waterfall Life-Cycle Model  
(e) Rapid-Prototyping Life-Cycle Model  
(f) Open-Source Life-Cycle Model  
(g) Agile Processes  
(h) Synchronize-and-Stabilize Life-Cycle Model  
(i) Spiral Life-Cycle Model  
Of these seven, which do you think fits most closely with the software development process you think you would feel comfortable with? What is it about this process that appeals to you?**   
I think that the Agile process fits most closely with the software development process that I would be comfortable with. I like it because it involves breaking down a large project and building it parts at a time. I have seen agile in the workplace and it is usually a lot better than waterfall. Likewise, it's easier to make changes to a project using agile. However, the one thing that I'm not too fond of is pair programming. I would rather program on my own machine and discuss code later. Once I'm in the zone I usually get stuck on what I'm doing. I'm also working at my own pace and would rather not have to work with someone else and disrupt my own flow.  

I would like to mention that most of the work I have done has been Code-and-Fix, even at my Co-op. Even though I know it's not a good methodology, that is a way in which I have worked on a project many times. I'm used to making something and "fixing" it until it's what it is desired to be.  
  
**8. This question is semi-optional — I don’t expect you to spend more that 15 minutes answering this, and I’ll be very lenient in grading this question. Open the paper Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I, which is recursive.pdf in the PDF directory of my Github account. Read Part 2 only, pages 2 to 8. I won’t ask you to study this paper, to do so would be an onerous assignment in itself. Write a one paragraph appreciation of Part 2. Those of you who are mathematically inclined may find that this suits your taste. For those of you who aren’t, this is an essential paper that you should at least have seen, even if you don’t have much patience with the mathematics.**   
I'm not a Math person at all and Math is undoubtedly my *least* favorite subject. However, the functions discussed in this paper remind me of topics I learned in Discrete Mathematics. While I don't like Math, I did like propositional phrases and conditional expressions. That was something that I was relatively good at and enjoyed. When I started taking classes like Algorithm Analysis, Computer Organization and Computer Architecture, I could see how it all came together. This article did a good job, I think, of explaining and defining the different types of expressions. The functions and forms section started to get a bit too complex for me, but otherwise I was able to follow along.
