Olivia Horace
Homework 2

1. What is the first step in creating a piece of software?
The first step in creating a piece of software is to gather the client's requirements. 

2. What is the difference in discovering what the client needs and discovering what the software should
do?
The clients needs may not accurately reflect what the software should do. The client, who may or may not have technical skills, will only be able to detail what they want the end product to look/behave like. From there, the actual software has to be developed. For example, a restaurant chain may want an app developed that will allow customers to order take out food. The implementation of this will involve determining how to software should act to meet these needs. Additionally, the client may not always know what they need, it's possible that he/she just knows what he/she wants. 

3. In what sense is a software engineer a generalist rather than a specialist?
A specialist is highly qualified in a specific area where as a generalist has roughly an even level of knowledge among many topics. As a result, software engineers must do more that "engineer" software They also have to be able to take requirements and turn them in to modules that can be constructed and implemented. Likewise, they also have to be skilled in quality assurance and testing. Finally, they also need to be able to demonstrate and defend their software. For this reason, they have to be skilled in all areas which would make them generalists. However, they should not be generalists in the average sense, they should actually be specialists in all areas as opposed to just having moderate knowledge in multiple areas. 

4. List some techniques the book identifies as useful for determining requirements, and for each, give one
reason why that technique might not be effective.
The techniques for creating a business model are then used to determine requirements. The book lists interviewing, questionnaires, observation and forms among these techniques. Interviewing can be structured with closed ended questions or unstructured with both open and closed ended questions. The fault here is that the developer may not gain relevant information if the question is too broad. Also, if the interviewer already has a preconceived notion about an application then the interview will not serve much of a purpose. The interviewer should be open minded regardless of what they may already know.
Questionnaires don't allow for follow ups immediately. Even though written out answers may be better thought out, there is still the drawback of time. Now, the developer will have to wait to receive the answers then decide how to proceed with any follow up questions. 
Examining forms may be time consuming and tedious. In some cases it may even be hard to understand. Asking for a verbal explanation may be a better option in some cases. 
Observations can be helpful but it can take a long time to analyze tapes, if video recording is the method used. Some members also disagree with the use of cameras, as it can be seen as an invasion of privacy. 

5. In what sense are requirements dynamic rather than static?
Requirements are dynamic because they can, and often times do, change. The initial requirements of a project may be modified, increased or even decreased throughout the development cycle. 

6. In your own words, state the difference between functional and nonfunctional requirements. Do you think that there is any such thing as a "nonfunctional" requirement?
A functional requirement is something that is essential for software to perform. A nonfunctional requirement refers to things outside of the actual software function such as compatible operating systems or performance. I don't really think there are nonfunctional requirements and all requirements should be considered functional. Technically, if a software has a nonfunctional requirement of being run on a Windows machine then it will probably not operate as expected on a Mac. To me, this is critical to the overall function of the software even though it isn't specifically related to the software itself. 

7. What is top-down analysis? You may also see this referred to as structured analysis. How is this
different than the case study in chapter 11 in the book?
Top down involves planning and learning the system before actual development begins. This usually involves delaying testing until most of the development has been completed. In the case study, the process was much more gradual. While requirements were being gathered they were still being revised. Gathering requirements was a process repeated until they were fine tuned. It differs from top-down because it dove straight into planning for the software.

8. Prototyping is a very controversial issue. Can you think of some reasons why many software engineers
think that prototyping is harmful?
Some engineers may think it's harmful because it is rushed. In the case of rapid prototyping, these prototypes are often built very quickly and may not even function. It can cause doubts as to whether the software will be built appropriately. Also, it can be counterproductive to show a client something that is barely working. The time spent to make and present a prototype could be used in building the actual software. 

9. Teams One and Two both have the responsibility for developing a software requirements specification
for a project. Team One has infrequent changes to its requirements specification, while Team Two has
very frequent changes to its requirements specification. Which team is doing the better job? Justify
your answer.
I believe Team Two is doing a better job however without knowing more information on the status of the project, it's hard to judge. I say Team Two because they are probably finding that the requirements they were given need to be updated/changed or be more specific. Essentially, their requirements are becoming better as they are frequently changed. 

10. More software defects are traceable to bad requirements analysis than to any other source. Why do
you think this is true?
I think this is true because poor planning leads to poor results. If you start out working towards a poor goal then the final outcome will also be poor. Bad requirements will result in bad software in the end. Likewise, the requirements are the starting point of a project so if the requirements phase is bad then everything else after will be just as bad. So it is important for the requirements to be as clear, relevant, and succinct as possible. 
