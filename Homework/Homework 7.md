# Olivia Horace  
## Homework 07, CPSC-4175  
  
#### 1. Where, in the software construction process, should testing occur? Explain your reasoning. ####  
Testing should occur during the entire software construction process. Testing is a very important part of development. It can be argued that it is one of the most important parts. For this reason, it's not good enough to just test at the end of the construction process. Testing throughout will locate errors and flaws before they become major or it becomes harder to pinpoint their origin. When testing is done consistently it is easier to find out if there are problems after new modules have been implemented into the overall product.  
  
#### 2. Explain the differences and similarities between verification and validation. ####  
**Verification** is the process of determining whether a workflow as been carried out correctly. Verification occurs at the end of each workflow.  
**Validation** is the evaluation process that determines whether the product satisfies its specifications. Both verification and validation involve evaluating software and determining whether or not it is up to par. However, *verification* is making sure that the workflow itself was performed correctly. *Validation* is making sure that the product is actually satisfying its expectations. In other words, *verification* is making sure that software is built properly and *validation* is making sure that the software that has been built is what was actually supposed to be built.  
  
#### 3. Explain the difference between execution-based-testing and non-execution-based-testing. ####  
**Non-execution-based testing** is testing software without running any test cases. This can be done by reading through code carefully, line-by-line. I can also be done by analyzing the software mathematically.  
**Execution-based testing** involves inferring the behavioral properties of a product based on the results of executing the product. The product has to be executed in a known environment with specified inputs.  
  
#### 4. Discuss the concept of quality as that word is used in the phrase "software quality assurance." ####  
**Quality** is used to describe to what extent software satisfies its specifications. However, quality has to be incorporated into the product from the beginning of the development cycle all the way through to the end. The developers should be building quality software as it is not solely the job of software quality assurance to ensure, or even produce, the quality within a product.  
  
#### 5. Why should software not be tested by the implementers, and not implemented by the testers? Think of an illustration from your life experience (not necessarily IT related). ####  
Software should not be tested by the implementers because they already have an in-depth knowledge of the product. So, the product may not be tested as thoroughly because they may assume something is foolproof. Likewise, they may only test things that fit within the scope. For instance, a field may ask for a positive integer. The implementer knows that the variable for this will only hold an integer value so they may test a negative number to make sure that the program will not allow it. But they may overlook testing what happens if a letter is entered, if a space is entered, if someone just hits the enter key or anything else of the sort. That's why it's best for someone who had no role in developing the product to test it. It is more likely that true defects will be found this way.  
Likewise, software should not be implemented by testers because it is outside of their realm. Testers have the non-objective point-of-view needed to test software. However, that is not the same as being able to implement software. Testing and implementing require very different skill sets.  
  
#### 6. Explain the difference between correctness proofs and execution testing? Which is "better?" Why? ####  
A **correctness proof** is a mathematical technique for showing that a product is correct and satisfies its specifications. There are 3 aspects involved in correctness proof: input specifications, output specifications and loop invariants. Execution testing is based on the behavior of a product in a known environment with specific inputs. But this style of testing has limitations. First, the product is tested using known inputs and examines the output. Then the tester has to determine if anything is wrong. Also, there really is no "known" environment, we can't ever really know everything about an environment. Finally, the inputs being selected is troublesome because in real execution of the product, the input can be anything.  
For these reasons, I think correctness proof may be better because it uses math to determine if software satisfies its specifications. Numbers provide hard, quantitative results. No one has to make any inferences, assumptions or draw conclusions.  
  
#### 7. Read the article The Coming Software Apocalypse in the PDF directory. Write a one paragraph appreciation of the article. ####  
I never knew there was 911 crisis such as the one described in the article. I can't' imagine really needing the police, like the lady whose house was broken into, and my call not going through. I agree with many of the points made. The flexibility of software can be both a blessing and a curse. The 911 crisis was caused because the number of calls was greater than the max number of calls programmers had in their code. One line of code made all the difference in people being able to contact emergency services. I especially like the quote that "[t]he software did exactly what it was told to do. The reason it failed is that it was told to do the wrong thing". That is something very important to keep in mind. When we create software it is only capable of doing what it is designed to do. If it is designed to do something "wrong", then that is exactly what it will do.  
  
#### 8. In regard to that article, how do you see your role in addressing the concerns raised in that article? Do you really think that there will be a "software apocalypse?" ####  
I don't think that there will be a software apocalypse. When I enter the workforce after graduation, I hope that I will be able to make technology a benefit to all. I want to improve technology and not let it get to the point where something like a "software apocalypse" can happen. However, as mentioned in the article, the serious problems have been the results of requirements. I honestly don't want to write requirements, ever. I would much rather write and implement code. As a result, I'm not sure what I can contribute in the future to address this issue. However, I am very optimistic about the future of technology and Computer Science. Even though it may get worse before it gets better, it will definitely get better.
