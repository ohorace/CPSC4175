## Olivia Horace  
### Homework 08, CPSC-4175  

**1. The book notes that the Unified Process is not "a specific series of steps." It notes that "[i]nstead, the Unified Process should be viewed as an adaptable methodology." Given this, how should you approach the content in this chapter that seems to present the Unified Process as a specific series of steps? How would you approach this chapter if you in fact viewed the Unified Process, not as a process, but simply as a methodology?**  
The content of this chapter should be approached as if the Unified Process is not a set of steps. As explained, even though "process" is in the name, it's actually not a process. It is adapted based on the software being developed. Therefore, it should be viewed as a flow that can be changed and is still "correct" even when it has been changed. There is no one way to follow the Unified Process.  
  
**2. The book states that "[t]he object-oriented paradigm is an iterative-and-incremental methodology." Do you think that this is a true statement? How is this similar to our class discussions of a spiral approach to software engineering? Is there any difference between these two views, and if so, what is the difference?**  
In an iterative-and-incremental methodology, each workflow consists of a number of steps that are repeatedly performed until the development team has an accurate UML diagram. This is similar to the spiral approach because it involves steps that are repeated multiple times for the same end goal. However, I would say a difference is that in spiral, the phases themselves are repeated. In iterative and incremental design, the steps within each flow are repeated as many times as necessary before progressing to the next step.  
  
**3. In class, we are using an iterative process with four phases: analysis, design, implementation, and testing. The book discusses the five core workflows of the Unified Process. List the five core workflows, and for each, give a brief summary of the workflow.**  
Requirements Workflow - determining the needs of the client by mainly understanding where the software is to be operated  
Analysis Workflow - analyze and refine the requirements to be able to know what is necessary to develop a software product correctly  
Design Workflow - refine the artifacts of the analysis workflow until it is in a form that can be implemented  
Implementation Workflow - implement the software
Test Workflow - testing by the implementers as well as quality assurance  
  
**4. What is the relationship between the software project management plan and the software development process? Do you think that a software project management plan can replace an explicit software development process? Why or why not?**  
The software project management plan is a document that shows the separate workflows of the development process. It shows what is involved in each task as well as the deadlines. So essentially it is a map of the software development process. I actually think it could replace the software development process if it is detailed enough. If every single step, along with deadlines, is reasonably mapped out, then yes it could replace it. It would just take a lot of research and data gathering to be able to do this.    

**5. Section 3.7 discusses testing with regard to four process areas: requirements artifacts, analysis artifacts, design artifacts, and implementation artifacts. What is the difference between the test workflow discussed in the chapter, and the testing of the artifacts produced in each of the five process areas? Do you think that this is an inconsistency in the book's treatment of testing?**    
In this section testing is divided into testing for each workflow. Requirement artifacts must be traceable from analysis artifacts back to a specific requirement. Analysis artifacts are tested by means of review typically. The goal is to make sure that specifications are feasible. Design artifacts are also tested for being traceable so that they can be linked to an analysis artifact. Implementation artifacts are tested by running code against test cases. Code reviews are also used to find programming faults.  I think that this is contrary to how the book has previously presented testing. Testing has mainly been presented as solely testing an implementation for errors. However, this section provides definitions for testing on the stage/phase level to include more than just the implementation.   
  
**6. If it is true, as the book claims, that "[p]ostdelivery maintenance is not an activity grudgingly carried out after the product has been delivered and installed on the client's computer," how do you fit postdelivery maintenance into an iterative, spiral development model?**  
Postdelivery maintenance fits into a spiral development model because it is embedded in the process. It should be planned for from the beginning of a project. Any coding done on a product should be written in a way that will allow it to be easily maintained in the future. Postdelivery maintenance should not be done at the end because it should be completed while the development process is ongoing. 

**7. Look at figure 3.10 on page 88 of the book. This figure seems to suggest a model of five workflows(requirements, analysis, design, implementation, and testing), with each workflow consisting of four phases (inception, elaboration, construction, and transition). In class, we have talked about an iterative, spiral model with four phases for each iteration (analysis, design, implementation, and testing). Do you think that these two approaches are mutually exclusive? Do you think that they are mutually supportive? Before you answer, review your response to the first question.** 
I think these two approaches are mutually supportive. In the spiral method, the analysis workflow is absorbed into the requirements phase. Likewise, the four phases performed in each of the five workflows are essentially the steps taken in each phase of the 4 step spiral process. It appears to me that there is more repetition in the five step process but essentially they both could work hand in hand.  

**8. Look at figure 3.2 on page 94. In a sense, the waterfall method can be easily adopted to an iterative, spiral development model, using the waterfall approach to model each iteration, i.e., not a "waterfall" but a series of rapids, or a cascade. Viewed in this way, how do you think model 3.2a and 3.2b would actually differ in a real-life project? Do you think that they would basically amount to the same thing, or do you think that they would be fundamentally different?**    
Primarily, I don't think that these processes would be that concrete in a real life project. Things are always changing and often times projects don't stay on the track that they initially start on. However, I do think that the Unified Process model would have more time built into it, or more "cascades", to include all steps within in phase.  

**9. The last section discusses software process improvement. What is the difference between software improvement, and software process improvement? How important do you think that software process improvement is in the field of software engineering?**  
Software process improvement is the process of making the steps to design software more productive and more efficient. The process is enhanced to make it flow better. Software improvement is improving the software that is being built. I think it is very important to improve the software process because technology is changing very rapidly. So it is important to make sure our processes are up to date so that technology is being utilized the most efficient way. So the processes should be updated in the event that they become outdated. 
